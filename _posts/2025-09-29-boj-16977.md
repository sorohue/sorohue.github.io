---
title: BOJ 16977 히스토그램에서 가장 큰 직사각형과 쿼리
description: sorohue가 PS하는 블로그
date: 2025-09-29T01:51:44.295Z
preview: ""
tags: [pbs, segtree]
categories: [PS, BOJ]
toc: "true"
toc_sticky: "true"
---

[문제 링크](https://www.acmicpc.net/problem/16977)입니다.

## 문제 요약

히스토그램의 $[l,r]$ 구간 안에 넣을 수 있는 너비 $w$짜리 직사각형의 최대 높이를 $Q$번 구하세요.

## 결정 문제 풀기

$[l, r]$ 안에 $w \times h$ 크기의 직사각형을 집어넣을 수 있는 지 판정하는 문제를 해결해 봅시다.

히스토그램에 직사각형을 넣는 문제를 푸는 방법 중 하나로 Union-Find를 이용해 높이가 높은 직사각형부터 합치면서 연결 요소의 너비를 구하는 방법이 있습니다. 이를 응용하면 높이가 $h$ 이상인 직사각형만 남긴 채로 연결 요소를 구성한 뒤, 구간 $[l, r]$에 포함되는 최대 연결 요소 크기를 구하는 방식으로 위의 결정 문제를 해결할 수 있습니다.

최대 연속 합을 구하는 세그먼트 트리를 이용하면 $h$가 큰 순서대로 직사각형을 추가 후 구간 최대 연속 합을 구하는 방식으로 ${\cal O}(N \lg N)$에 한 쿼리를 해결할 수 있습니다. 총 시간 복잡도는 ${\cal O}(NQ \lg N)$이라 시간 초과를 피하기 어렵습니다.

## 최적화 문제 풀기

직사각형이 추가되는 모든 경우마다 구간 최대 판정을 할 필요가 없습니다. $h$에 대한 이분 탐색을 적용하면 쿼리마다 ${\cal O}(\lg N)$번의 최댓값 쿼리로 답을 얻어낼 수 있습니다.

이 과정에서 ${\cal O}(\lg N)$번의 세그먼트 트리 재구성이 필요합니다. 각 쿼리마다 세그먼트 트리를 따로 초기화해서 쓸 필요는 없으니 세그먼트 트리를 한 번 구성할 때마다 모든 쿼리에 대한 이분 탐색을 동시에 처리해 줄 수 있습니다. 총 ${\cal O}(Q \lg N)$번의 쿼리와 ${\cal O}(N \lg N)$번의 업데이트가 필요하므로, 시간 복잡도 ${\cal O}((N+Q) \lg^2 N)$에 문제를 해결할 수 있습니다.

## 코드

```cpp
#include<bits/stdc++.h>
#define mid (l+r>>1)
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;

struct Node{
	int tot, lcnt, rcnt, ans;
} tree[404040];

struct Qry{
	int l, r, w;
}; vector<Qry> q;
vector<int> bucket[101010];
vector<int> rollback;

int L[101010], R[101010];
vector<pii> h;

Node merge(Node l, Node r){
	Node ret;
	ret.tot = l.tot+r.tot;
	ret.lcnt = l.lcnt+(l.lcnt == l.tot)*r.lcnt;
	ret.rcnt = r.rcnt+(r.rcnt == r.tot)*l.rcnt;
	ret.ans = max({l.ans, r.ans, l.rcnt+r.lcnt});
	return ret;
}

void init(int now, int l, int r){
	tree[now] = {r-l+1,0,0,0}; if(l == r) return;
	init(now<<1, l, mid); init(now<<1|1, mid+1, r);
}

void upd(int now, int l, int r, int i){
	if(l == r){
		tree[now] = {1,1,1,1};
		return;
	}
	if(i <= mid) upd(now<<1, l, mid, i);
	else upd(now<<1|1, mid+1, r, i);
	tree[now] = merge(tree[now<<1], tree[now<<1|1]);
}

Node qry(int now, int l, int r, int L, int R){
	if(l > R || L > r) return {0,0,0,0};
	if(L <= l && r <= R) return tree[now];
	return merge(qry(now<<1, l, mid, L, R), qry(now<<1|1, mid+1, r, L, R));
}

int main(){
	cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
	int n; cin >> n;
	for(int i = 1; i <= n; i++){
		int t; cin >> t; h.push_back({t, i});
	} h.push_back({1234567890, 0});
	sort(h.begin(), h.end(), greater<>());

	int Q; cin >> Q; q.push_back({0,0,0});
	for(int i = 1; i <= Q; i++){
		int l, r, w; cin >> l >> r >> w;
		q.push_back({l, r, w});
		L[i] = 0; R[i] = n;
	}
	while(1){
		init(1, 1, n);
		bool done = 1;
		for(int i = 1; i <= Q; i++){
			if(L[i] >= R[i]) continue;
			done = 0;
			bucket[L[i]+R[i]>>1].push_back(i);
			rollback.push_back(L[i]+R[i]>>1);
		}
		if(done) break;
		for(auto& j : bucket[0]) L[j] = 1;
		for(int i = 1; i <= n; i++){
			upd(1, 1, n, h[i].second);
			for(auto& j : bucket[i]){
				if(qry(1, 1, n, q[j].l, q[j].r).ans >= q[j].w) R[j] = i;
				else L[j] = i+1;
			}
		}
		for(auto& i : rollback) bucket[i].clear();
		rollback.clear();
	}
	for(int i = 1; i <= Q; i++) cout << h[L[i]].first << '\n';
	
}
```
